#+TITLE: A nicer numpy
#+AUTHOR: Dima Kogan

#+LaTeX_HEADER: \setbeamertemplate{navigation symbols}{}
#+OPTIONS: toc:nil

* What is this about?
Two libraries to make working in numpy nicer.

- These are public tools, available for some years
- Installable from Debian and related distros.
- Python2 and Python3 both supported

** numpysane (https://github.com/dkogan/numpysane)
- Provides some routines to improve core functionality
- These are new functions, so there're no compatibility concerns

** gnuplotlib (https://github.com/dkogan/gnuplotlib)
- Plotting
- Does a similar thing as =matplotlib= but (I claim) better

** notes                                                           :noexport:

- Slides linked at the above URLs
- Talk about some tools I wrote to solve my problems. The things I work on
  aren't that different from the things many other people work on, so sharing
  could be useful

- Have been out for a while, but I haven't done much proselytizing until now.

- I use these all the time for all sorts of things

- There's plenty of documentation online, so I'll give a very quick overview of
  the APIs, and then show some demos.

* What's wrong with numpy?
- Some core functionality is mysterious and unintuitive
- Things work as expected /only/ with 2-dimensional arrays, no more and no less

Areas addressed by =numpysane=:

- Nicer array manipulation
- Nicer basic linear algebra routines
- Better broadcasting support

** notes                                                           :noexport:

I used perl and PDL (http://pdl.perl.org/) for many years. Solid core. Not very
widely used. Not a lot of library support.

Eventually I moved to python and numpy to discover that both aren't nearly as
nice as they were made out to be. numpy's issues are complementary to PDL: it
has lots of users and lots of libraries, but the core functionality isn't great.

Many of the issues stem from a fundamental design assumption that everybody has
only has 2-dimensional arrays.

I'll briefly describe the issues and solutions. More is available in the
documentation

* Matrix concatenation
Basic example: stick two identical 2D arrays together to extend each row

- The docs say to use =hstack()=

Let's try it:

#+BEGIN_EXAMPLE
>>> import numpy as np
>>> arr32 = np.arange(3*2).reshape(3,2)
>>> print(arr32)
[[0 1]
 [2 3]
 [4 5]]

>>> print(arr32.shape)
(3, 2)
#+END_EXAMPLE

* Matrix concatenation
What do we expect =hstack(arr32,arr32)= to do?

#+BEGIN_EXAMPLE
[[0 1 0 1]
 [2 3 2 3]
 [4 5 4 5]]
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
[[0 1]
 [2 3]
 [4 5]
 [0 1]
 [2 3]
 [4 5]]
#+END_EXAMPLE

?

** notes                                                           :noexport:
These are "horizontal" and "vertical" and "depth". I'd argue that if you have
N-dimensional arrays, these words have limited meaning, but that's what numpy
does. And what if you want the 4th dimension? I'm convinced that nobody knows
how to use these functions. Let's try

* Matrix concatenation
This was a trick question. Here's what it does:

#+BEGIN_EXAMPLE
>>> np.hstack(arr32,arr32)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: hstack() takes 1 positional argument ...
    ... but 2 were given
#+END_EXAMPLE

Apparently =hstack()= wants an iterable of the arguments, instead of the
arguments themselves

* Matrix concatenation
Fine. Here's what it does if you feed it what it wants:

#+BEGIN_EXAMPLE
>>> print(np.hstack((arr32,arr32)))
[[0 1 0 1]
 [2 3 2 3]
 [4 5 4 5]]
#+END_EXAMPLE

That makes sense! Looks "horizontal".

* Matrix concatenation
What if I don't feed it strictly 2D matrices?

#+BEGIN_EXAMPLE
>>> arr132 = np.arange(3*2).reshape(1,3,2)
>>> print(arr132)
[[[0 1]
  [2 3]
  [4 5]]]

>>> print(arr132.shape)
(1, 3, 2)
#+END_EXAMPLE

* Matrix concatenation
Same question as before: what do we expect =hstack((arr132,arr132))= to do?

#+BEGIN_EXAMPLE
[[[0 1 0 1]
  [2 3 2 3]
  [4 5 4 5]]]
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
[[[0 1]
  [2 3]
  [4 5]
  [0 1]
  [2 3]
  [4 5]]]
#+END_EXAMPLE

or something else?

* Matrix concatenation
Here's what it does:

#+BEGIN_EXAMPLE
>>> print(np.hstack((arr132,arr132)))
[[[0 1]
  [2 3]
  [4 5]
  [0 1]
  [2 3]
  [4 5]]]

>>> np.hstack((arr132,arr132)).shape
(1, 6, 2)
#+END_EXAMPLE

Whoa. That is /not/ horizontal at all! I would have expected a result with shape
=(1,3,4)=

* Matrix concatenation
What if I give it 1-dimensional arrays?

#+BEGIN_EXAMPLE
>>> arr3  = np.arange(3)
>>> arr13 = np.arange(3).reshape(1,3)
>>> print(arr3)
[0 1 2]

>>> arr3.shape
(3,)

>>> print(arr13)
[[0 1 2]]

>>> arr13.shape
(1, 3)
#+END_EXAMPLE

* Matrix concatenation
#+BEGIN_EXAMPLE
>>> np.hstack((arr3,arr3)).shape
(6,)

>>> np.hstack((arr13,arr13)).shape
(1, 6)

>>> np.hstack((arr13,arr3)).shape
ValueError: all the input arrays must have ...
    ... same number of dimensions
#+END_EXAMPLE

- Do the stacking functions want the dimension counts to match up, or something?

Well, no:

#+BEGIN_EXAMPLE
>>> np.vstack((arr13,arr3))
[[0 1 2]
 [0 1 2]]
#+END_EXAMPLE

* Matrix concatenation
So what's wrong?

- *numpy is inconsistent about which is the most significant dimension in an
  array*

There's an arbitrary design choice that must be made: if I stack =N= arrays of
shape =(A,B,C)= into a new array, do I get

- an array of shape =(N,A,B,C)= or
- an array of shape =(A,B,C,N)=?

Most of numpy makes the /first/ choice, but some of it (concatenation functions
most notably) makes the second choice

* Dimensionality example
Example:

- Let's say I have a 1-dimensional array containing simultaneous temperature
  measurements at different locations:

#+BEGIN_EXAMPLE
>>> print(temperatures)
[ t_place0 t_place1 t_place2 ... ]

>>> print(temperatures.shape)
(Nlocations,)

#+END_EXAMPLE

To access temperatures at different locations in this array, I look along the
first dimension (=axis = 0=). This is a 1-dimensional array, so that's also the
last dimension (=axis = -1=).

* Dimensionality example
Let's now say I have measured all the temperatures multiple times throughout the
day, and I make a joint array using the /first/ convention above

#+BEGIN_EXAMPLE
>>> print(temperatures)
[[ t_time0place0 t_time0place1 t_time0place2 ... ]
 [ t_time1place0 t_time1place1 t_time1place2 ... ]
 ...]

>>> print(temperatures.shape)
(Ntimes, Nlocations)
#+END_EXAMPLE

- I want to use the same axis index to access different locations
- If I count dimensions from the end, I can do that: =axis = -1= refers to the
  different locations in both cases
- But if I count dimensions from the front, this doesn't work: locations /were/
  at =axis = 0= but now they're at =axis = 1=

** notes                                                           :noexport:
Now let's say I have measured the temperatures multiple times throughout the
day, and I make a joint array using the first convention above

To access the temperatures at different locations in /this/ array I'd like to be
able to use the same axis index. If I count dimensions from the end, I can do
this: =axis = -1= refers to the different locations here and before.

But if I count dimensions from the front, this doesn't work: locations /were/ at
=axis = 0= but now they're at =axis = 1=.

* Dimensionality example
If I used the /second/ convention above to produce an array of shape
=(Nlocations, Ntimes)= then the locations are at =axis = 0= in both cases. /But/
the arrays would be printed differently:

- the location axis would be printed horizontally in the 1D array, and
  vertically in the 2D array

So:

- numpy printing effectively counts dimensions from the back
- =hstack()= counts dimensions from the front. It /should be/ concatenating
  along =axis = -1= (the last one)
- But instead in concatenates along =axis = 1= (the 2nd one) with special-case
  rules about what to do with 1-dimensional arrays that don't have a 2nd axis
- For 2D arrays the 2nd axis /is/ the last axis, but for 3D arrays it isn't

** notes                                                           :noexport:
I can keep pointing out issues in these functions for a long time, but that's
not useful: they're all broken.

Fundamental issue: an inconsistent dimensionality convention.

The way arrays are printed, the innermost dimension is the /last/ one: the
dimension printed horizontal is =axis = -1=. So axes should be counted from the
end. But the numpy functions for concatenation count them from the front.

* Matrix concatenation with numpysane
There are two functions, both stolen from the PDL project.

- =glue()= concatenates any N arrays along the given axis
- =cat()= concatenates N arrays along a new outer dimension

These both add leading length-1 dimensions to the input as needed: "something"
is logically equivalent to "1 of something". This is one of the /broadcasting/
rules I'll get to in a bit

** notes                                                           :noexport:
Nothing is "horizontal" or "vertical". axes should be given from the end
(axis<0). Some functions actually require this: glue(axis>=0) will barf

* Matrix concatenation with numpysane
=nps.glue()= works as expected:

#+BEGIN_EXAMPLE
>>> import numpysane as nps

>>> nps.glue(arr32, arr32,  axis=-1).shape
(3, 4)

>>> nps.glue(arr32, arr32,  axis=-2).shape
(6, 2)

>>> nps.glue(arr132,arr132, axis=-1).shape
(1, 3, 4)

>>> nps.glue(arr13, arr3,   axis=-1).shape
(1, 6)

>>> nps.glue(arr13, arr3,   axis=-2).shape
(2, 3)
#+END_EXAMPLE

* Matrix concatenation with numpysane
=nps.cat()= works as expected too. It always adds a new leading dimension

#+BEGIN_EXAMPLE
>>> nps.cat(arr32,arr32).shape
(2, 3, 2)

>>> nps.cat(arr132,arr32).shape
(2, 1, 3, 2)
#+END_EXAMPLE

* Matrix multiplication
The funny business extends to other core areas of numpy. For instance
multiplying matrices is non-trivial

- Up until numpy 1.10.0 =np.dot()= was the function for that, and it is
  surprising in all sorts of ways
- In 1.10.0 we got =np.matmul=, which is /much/ better, but even then it has
  strange corners. Trying to compute an outer product:

#+BEGIN_EXAMPLE
>>> a = np.arange(5).reshape(5,1)
>>> b = np.arange(3)

>>> np.matmul(a,b)
ValueError: matmul: Input operand 1 has a mismatch in
   its core dimension 0, with gufunc signature
   (n?,k),(k,m?)->(n?,m?) (size 3 is different from 1)
#+END_EXAMPLE

* Matrix multiplication with numpysane
numpysane provides its own =matmult()= routine that does what one expects:

#+BEGIN_EXAMPLE
>>> nps.matmult(a,b).shape

(5, 3)
#+END_EXAMPLE

There're many more functions in numpysane in this area. Everything's documented,
and I'd like to move on to...

* Broadcasting
What is broadcasting?

- /Broadcasting/ is a generic way to vectorize functions
- A broadcasting-aware function has a /prototype/: it knows the dimensionality
  of its inputs and of its outputs
- When calling a broadcasting-aware function, any extra dimensions in the input
  are automatically used for vectorization

* Broadcasting: an example
This is best described with an example: a broadcasting-aware innner product. An
inner product (also known as a dot product) is a function that

- takes in two identically-sized 1-dimensional arrays
- outputs a scalar

If one calls a broadcasting-aware inner product with two arrays of shape (2,3,4)
as input, it would

- compute 6 inner products of length-4 each
- report the output in an array of shape (2,3)

Because =nps.inner()= knows the dimensionality of its inputs and of its outputs,
it can figure out how to parse the input arrays

* Broadcasting: an example
#+BEGIN_EXAMPLE
>>> a234 = np.arange(2*3*4).reshape(2,3,4)

>>> print(a234)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]

>>> print(nps.inner(a234,a234))
[[  14  126  366]
 [ 734 1230 1854]]
#+END_EXAMPLE

The values in the output are =inner([0,1,2,3], [0,1,2,3])= and
=inner([4,5,6,7],[4,5,6,7])= and so on.

* What about the stock broadcasting support?
What stock broadcasting support?
- It's sparse and incomplete
- Little end-user awareness that it exists

* Broadcasting rules
In short:

- Line up the shapes of the inputs to their /trailing/ dimensions
- Match the trailing dimensions with the expected shapes of the inputs
- Any leading dimensions left over are used for vectorization
- The extra leading dimensions must be compatible across all the inputs. This
  means that each leading dimension must either
  - equal 1
  - be missing (thus assumed to equal 1)
  - equal to some positive integer >1, consistent across all arguments
- The leading dimensions of the inputs determine the shape of the output

* Broadcasting: an example
Let's write a broadcasting-aware inner product.

#+BEGIN_EXAMPLE
import numpysane as nps
@nps.broadcast_define( (('n',), ('n',)), () )
def inner(a,b):
    # We could use numpy for this: return a.dot(b)
    sum = 0.
    for i in range(len(a)): sum += a[i]*b[i]
    return sum
#+END_EXAMPLE

* Broadcasting: an example
- We wrote a function =inner(a,b)= that computes /one/ inner product. It knows
  nothing about vectorization
- And it can assume that =a= and =b= are 1-dimensional arrays of the same length
- Then we used the =nps.broadcast_define()= decorator to add broadcasting
  awareness to this function
- The decorator is told that there are 2 inputs, that have dimensions =('n',)=
  each. It's the same =n= for both of them, so ...
- the internal =nps.broadcast_define()= machinery will make sure that the
  /last/ dimension of both inputs matches
- If we call =inner()= with more than 1-dimensional input, we'll get multiple
  inner products computed, and an array of output returned

* Broadcasting: an example
So we can give it two arrays, and get inner products of each corresponding row:

#+BEGIN_EXAMPLE
>>> a234 = np.arange(2*3*4).reshape(2,3,4)

>>> print(inner(a234,a234).shape)
(2,3)
#+END_EXAMPLE

Or we can compute the inner product or each row of one array to some arbitrary
vector

#+BEGIN_EXAMPLE
>>> a234 = np.arange(2*3*4).reshape(2,3,4)
>>> a4   = np.arange(4)

>>> print(inner(a234,a4).shape)
(2,3)
#+END_EXAMPLE

* Broadcasting: more involved example
Let's say we have a function with input prototype

- =( (3,), ('n',3), ('n',), ('m',) )=

given inputs of shape

#+BEGIN_EXAMPLE
  (1,5,    3)
  (2,1,  8,3)
  (        8)
  (  5,    9)
#+END_EXAMPLE

The broadcasting logic will set =n = 8= and =m = 9=.

The call will return an output array of shape (2,5, ...), where ... is the shape
of each output slice.

* Broadcasting: summary
- This is a very powerful technique. The =nps.broadcast_define()= decorator is
  written in Python and wraps Python code. With lots of iterations this is
  /slow/.

- A much faster analogue exists in C: =nps.numpysane_pywrap()=. The iteration
  code and the code for the inner function are all in C, so this is fast. Please
  see the documentation for more detail.

- A stock numpy broadcasting-in-C API exists:

  https://docs.scipy.org/doc/numpy-1.13.0/reference/c-api.generalized-ufuncs.html

  I found this after implementing my own, and have not tried it.

* Plotting: gnuplotlib
Let's switch gears, and talk about plotting.

- As with the numpy core, there's a dominant choice here: matplotlib
- I'm not aware of any /major/ issues: if it's not pissing you off right now,
  there probably isn't a lot of reason to switch to my library

However, numpy ...

- is python-specific
- is slow
- has a weird API
- is missing useful interactivity

** notes                                                           :noexport:
At this point in my perl -> python transition I was getting peeved. I didn't see
anything as egregiously annoying in matplotlib as in core numpy, but it does a
whole lotta stuff that I don't like, so I decided to fix that too.

* Plotting: gnuplotlib
=gnuplotlib=: a plotting library for numpy

- Uses =gnuplot= as the plotting backend, so
  - The plots look and interact like =gnuplot= plots have for decades
  - It's fast
  - Lots of features and backends available

- Has a (claimed) reasonable API
- A direct port of =PDL::Graphics::Gnuplot=

** notes                                                           :noexport:

I make a lot of plots in my day to day, outside of python most of the time. I'd
like all my plots to look and feel the same. There's absolutely no reason for
any numpy-based plotting library to actually implement their own backend. If
their backend is amazing, then everybody else (python or not) should use it. If
it's not amazing, they should find an amazing one, and use it.

I'm sure matplotlib is more powerful than gnuplot in some ways, but when they
rewrote that particular world, they missed lots of nice things.

* Plotting: gnuplotlib design choices
- One =plot()= function does everything
  - Can still build up the plot components programmatically with python
- =gnuplotlib= is a thin shim: strings are passed to =gnuplot= verbatim (like in
  =feedgnuplot=)
  - So we get a powerful library and a friendly learning curve

Introductory tutorial is available at

https://github.com/dkogan/gnuplotlib/blob/master/guide/guide.org

** notes                                                           :noexport:
Similar design choices as with feedgnuplot: the sysmtem is as hands-off as
possible. Any styling directives are passed on to gnuplot directly.

There's one class gnuplotlib: one instance is one gnuplot process and one plot
window. There's one plotting function.

The various datasets and directives are all given to this one function with one
function call. If we need to gather many arguments to make a complicated plot,
we can build them up using the language we already have: python. This is in
contrast to how matplotlib does it, where you make multiple function calls to do
anything, and thus there's an API to learn.

* Plotting: gnuplotlib: a /very/ brief tutorial
To plot something, just call plot:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot(np.sin(th))
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot(np.sin(th))
#+END_SRC

- We're plotting in 2D, so default is =tuplesize=2= arrays
- We gave it just 1 array, so integers 0,1,2,... were used for the x

* Plotting: gnuplotlib: a /very/ brief tutorial
- We can pass in 2 arrays to make a scatter x-y plot:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th), square = True)
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th), square = True)
#+END_SRC

- We passed in /two/ arrays
- We also passed in =square = True=. This is a /plot option/ to autoscale the x
  and y axes evenly. Otherwise the circle will looks like an ellipse

* Plotting: gnuplotlib: a /very/ brief tutorial
- It's possible to have more values per point. For instance:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th),
        # The angle (in degrees) is shown as the color
        th * 180./np.pi,
        tuplesize = 3,
        _with     = 'linespoints palette',
        square    = True)
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th),
        # The angle (in degrees) is shown as the color
        th * 180./np.pi,
        tuplesize = 3,
        _with     = 'linespoints palette',
        square    = True)
#+END_SRC

- The style =linespoints palette= is given to =gnuplot= directly. =gnuplotlib=
  doesn't know what that means
- =tuplesize=3= tells =gnuplotlib= that there are 3 values per point. Because of
  =palette=, these will be interpreted as x,y,color
- The =gnuplot= documentation talks in detail about what kind of input each
  style expects

* Plotting: gnuplotlib: a /very/ brief tutorial
An explicit invocation of =plot()= looks like this:

#+BEGIN_SRC python :exports code
plot( curve, curve, ..., plot_options )
#+END_SRC

where each =curve= is a =tuple=:

#+BEGIN_SRC python :exports code
curve = (array, array, ..., curve_options)
#+END_SRC

- /plot options/ apply to the whole plot, and are given as keyword args to
  =plot()=
- /curve options/ apply to each separate curve (dataset); given in a =dict()= in
  the end of each =curve= tuple. Or defaults given in the =plot()= kwargs
- If we have one dataset, we can inline the tuples, like we did above

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( ( th, np.sin(th), ),
         ( th, np.cos(th), ),
         ( th, th, dict(_with = 'points ps 1') ),
         _with = 'lines',
         xlabel = "Angle (rad)",
         title  = "2 with lines and 1 with points")
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( ( th, np.sin(th), ),
         ( th, np.cos(th), ),
         ( th, th, dict(_with = 'points ps 1') ),
         _with = 'lines',
         xlabel = "Angle (rad)",
         title  = "2 with lines and 1 with points")
#+END_SRC

- We passed in 3 tuples, one for each dataset
- We passed in the =xlabel= plot option to label the x axis
- We passed in the =title= plot option to title the plot
- We passed in the default =with= curve option: =lines=
- 2/3 datasets don't set their own =with=, so they use =lines=
- 1/3 plots with =points ps 1= instead. =gnuplotlib= doesn't know what that is,
  but =gnuplot= knows that =ps= is a synonym for =pointsize=

** notes                                                           :noexport:
The arguments can be built up incrementally with python

* Plotting: gnuplotlib: a /very/ brief tutorial
- Broadcasting is fully supported:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( th,
         nps.cat(np.sin(th),
                 np.cos(th)),
         legend = np.array( ("sin", "cos"), ) )
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( th,
         nps.cat(np.sin(th),
                 np.cos(th)),
         legend = np.array( ("sin", "cos"), ) )
#+END_SRC

- I plotted two datasets, but didn't use tuples
- Using default =tuplesize=2=, and gave it two arrays:
  - First array has the expected shape of =(100,)=
  - Second array has the shape =(2,100)=
- This thus broadcasts: I get two plots: =sin(th)= vs =th= and =cos(th)= vs
  =th=
- curve options broadcast too: I have it two different =legend= options, and
  =gnuplotlib= knows to use each one for the two datasets

* Plotting: gnuplotlib: a /very/ brief tutorial

- What does this do?

#+BEGIN_SRC python :results none exports code
th    = np.linspace(0, 6*np.pi, 200)
z     = np.linspace(0, 5,       200)
size  = 0.5 + np.abs(np.cos(th))
color = np.sin(2*th)

gp.plot3d( np.cos(th) * nps.transpose(np.array((1,-1))),
           np.sin(th) * nps.transpose(np.array((1,-1))),
           z,
           size,
           color,
           tuplesize = 5,
           _with = 'points ps variable pt 7 palette',
           squarexy = True)
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports results :height 9
th    = np.linspace(0, 6*np.pi, 200)
z     = np.linspace(0, 5,       200)
size  = 0.5 + np.abs(np.cos(th))
color = np.sin(2*th)

gp.plot3d( np.cos(th) * nps.transpose(np.array((1,-1))),
           np.sin(th) * nps.transpose(np.array((1,-1))),
           z,
           size,
           color,
           tuplesize = 5,
           _with = 'points ps variable pt 7 palette',
           squarexy = True)
#+END_SRC

* Plotting: gnuplotlib

More or less that's it. Lots of examples in the guide:
- https://github.com/dkogan/gnuplotlib/blob/master/guide/guide.org

The API docs are on the main page:
- https://github.com/dkogan/gnuplotlib

* Thanks for listening!
The documentation and sources and links to this talk:

- https://github.com/dkogan/numpysane
- https://github.com/dkogan/gnuplotlib

Or you can

#+begin_example
apt install python3-numpysane python3-gnuplotlib
#+end_example

* init                                                             :noexport:
Local Variables:
eval: (progn
          (require 'ox-beamer)
          (setq org-confirm-babel-evaluate nil)
          (org-babel-do-load-languages
           'org-babel-load-languages
            '((python  . t)))
          (auto-fill-mode)
;; This is all very convoluted. There are 3 different advices, commented in
;; place
;;
;; THIS advice makes all the org-babel parameters available to python in the
;; _org_babel_params dict. I care about _org_babel_params['_file'] specifically,
;; but everything is available
(defun dima-org-babel-python-var-to-python (var)
  "Convert an elisp value to a python variable.
  Like the original, but supports (a . b) cells and symbols
"
  (if (listp var)
      (if (listp (cdr var))
          (concat "[" (mapconcat #'org-babel-python-var-to-python var ", ") "]")
        (format "\"\"\"%s\"\"\"" var))
    (if (symbolp var)
        (format "\"\"\"%s\"\"\"" var)
      (if (eq var 'hline)
          org-babel-python-hline-to
        (format
         (if (and (stringp var) (string-match "[\n\r]" var)) "\"\"%S\"\"" "%S")
         (if (stringp var) (substring-no-properties var) var))))))
(defun dima-alist-to-python-dict (alist)
  "Generates a string defining a python dict from the given alist"
  (let ((keyvalue-list
         (mapcar (lambda (x)
                   (format "%s = %s, "
                           (replace-regexp-in-string
                            "[^a-zA-Z0-9_]" "_"
                            (symbol-name (car x)))
                           (dima-org-babel-python-var-to-python (cdr x))))
                 alist)))
    (concat
     "dict( "
     (apply 'concat keyvalue-list)
     ")")))
(defun dima-org-babel-python-pass-all-params (f params)
  (cons
   (concat
    "_org_babel_params = "
    (dima-alist-to-python-dict params))
   (funcall f params)))
(unless
    (advice-member-p
     #'dima-org-babel-python-pass-all-params
     #'org-babel-variable-assignments:python)
  (advice-add
   #'org-babel-variable-assignments:python
   :around #'dima-org-babel-python-pass-all-params))
;; This sets a default :file tag, set to a unique filename. I want each demo to
;; produce an image, but I don't care what it is called. I omit the :file tag
;; completely, and this advice takes care of it
(defun dima-org-babel-python-unique-plot-filename
    (f &optional arg info params)
  (funcall f arg info
           (cons (cons ':file
                       (format "plot-%d.pdf"
                               (condition-case nil
                                   (setq dima-unique-plot-number (1+ dima-unique-plot-number))
                                 (error (setq dima-unique-plot-number 0)))))
                 params)))
(unless
    (advice-member-p
     #'dima-org-babel-python-unique-plot-filename
     #'org-babel-execute-src-block)
  (advice-add
   #'org-babel-execute-src-block
   :around #'dima-org-babel-python-unique-plot-filename))
;; If I'm regenerating ALL the plots, I start counting the plots from 0
(defun dima-reset-unique-plot-number
    (&rest args)
    (setq dima-unique-plot-number 0))
(unless
    (advice-member-p
     #'dima-reset-unique-plot-number
     #'org-babel-execute-buffer)
  (advice-add
   #'org-babel-execute-buffer
   :after #'dima-reset-unique-plot-number))
;; I'm using github to display guide.org, so I'm not using the "normal" org
;; exporter. I want the demo text to not contain the hardcopy= tags, but clearly
;; I need the hardcopy tag when generating the plots. I add some python to
;; override gnuplotlib.plot() to add the hardcopy tag somewhere where the reader
;; won't see it. But where to put this python override code? If I put it into an
;; org-babel block, it will be rendered, and the :export tags will be ignored,
;; since github doesn't respect those (probably). So I put the extra stuff into
;; an advice. Whew.
(defun dima-org-babel-python-set-demo-output (f body params)
  (with-temp-buffer
    (insert body)
    (beginning-of-buffer)
    (when (search-forward "import gnuplotlib as gp" nil t)
      (end-of-line)
      (insert
       "\n"
       "if not hasattr(gp.gnuplotlib, 'orig_init'):\n"
       "    gp.gnuplotlib.orig_init = gp.gnuplotlib.__init__\n"
       "plot_output_pdf = lambda: dict(hardcopy = _org_babel_params['_file'],\n"
       "                               terminal = 'pdfcairo solid color font \",20\" size 11in,{}in'.format(_org_babel_params.get('_height',5)) if 'file' in _org_babel_params['_result_params'] else {})\n"
       "gp.gnuplotlib.__init__ = lambda self, *args, **kwargs: gp.gnuplotlib.orig_init(self, *args,\n"
       "                                                                               **plot_output_pdf(), **kwargs )\n"))
    (setq body (buffer-substring-no-properties (point-min) (point-max))))
  (funcall f body params))
(unless
    (advice-member-p
     #'dima-org-babel-python-set-demo-output
     #'org-babel-execute:python)
  (advice-add
   #'org-babel-execute:python
   :around #'dima-org-babel-python-set-demo-output))
)
End:
