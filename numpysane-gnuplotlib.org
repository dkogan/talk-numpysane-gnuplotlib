#+TITLE: A nicer numpy
#+AUTHOR: Dima Kogan

#+LaTeX_HEADER: \setbeamertemplate{navigation symbols}{}
#+OPTIONS: toc:nil

* What is this about?
Two libraries to make working in numpy nicer.

- These are public tools, available for some years
- Installable from Debian and related distros.
- Python2 and Python3 both supported

** numpysane (https://github.com/dkogan/numpysane)
- Provides some routines to improve core functionality
- These are new functions, so there're no compatibility concerns

** gnuplotlib (https://github.com/dkogan/gnuplotlib)
- Plotting
- Does a similar thing as =matplotlib= but (I claim) better

** notes                                                           :noexport:

- Slides linked at the above URLs
- Talk about some tools I wrote to solve my problems. The things I work on
  aren't that different from the things many other people work on, so sharing
  could be useful

- Have been out for a while, but I haven't done much proselytizing until now.

- I use these all the time for all sorts of things

- There's plenty of documentation online, so I'll give a very quick overview of
  the APIs, and then show some demos.

* What's wrong with numpy?
- Some core functionality is mysterious and unintuitive
- Things work as expected /only/ with 2-dimensional arrays, no more and no less

Areas addressed by =numpysane=:

- Nicer array manipulation
- Nicer basic linear algebra routines
- Better broadcasting support

Mostly stolen from the PDL project

** notes                                                           :noexport:

I used perl and PDL (http://pdl.perl.org/) for many years. Solid core. Not very
widely used. Not a lot of library support.

Eventually I moved to python and numpy to discover that both aren't nearly as
nice as they were made out to be. numpy's issues are complementary to PDL: it
has lots of users and lots of libraries, but the core functionality isn't great.

Many of the issues stem from a fundamental design assumption that everybody has
only has 2-dimensional arrays.

I'll briefly describe the issues and solutions. More is available in the
documentation

* Matrix concatenation
Basic example: stick two identical 2D arrays together to extend each row

- The docs say to use =hstack()=

Let's try it:

#+BEGIN_EXAMPLE
>>> import numpy as np
>>> arr32 = np.arange(3*2).reshape(3,2)
>>> print(arr32)
[[0 1]
 [2 3]
 [4 5]]

>>> print(arr32.shape)
(3, 2)
#+END_EXAMPLE

* Matrix concatenation
What do we expect =hstack(arr32,arr32)= to do?

#+BEGIN_EXAMPLE
[[0 1 0 1]
 [2 3 2 3]
 [4 5 4 5]]
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
[[0 1]
 [2 3]
 [4 5]
 [0 1]
 [2 3]
 [4 5]]
#+END_EXAMPLE

?

** notes                                                           :noexport:
These are "horizontal" and "vertical" and "depth". I'd argue that if you have
N-dimensional arrays, these words have limited meaning, but that's what numpy
does. And what if you want the 4th dimension? I'm convinced that nobody knows
how to use these functions. Let's try

* Matrix concatenation
This was a trick question. Here's what it does:

#+BEGIN_EXAMPLE
>>> np.hstack(arr32,arr32)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: hstack() takes 1 positional argument ...
    ... but 2 were given
#+END_EXAMPLE

Apparently =hstack()= wants an iterable of the arguments, instead of the
arguments themselves

* Matrix concatenation
Fine. Here's what it does if you feed it what it wants:

#+BEGIN_EXAMPLE
>>> print(np.hstack((arr32,arr32)))
[[0 1 0 1]
 [2 3 2 3]
 [4 5 4 5]]
#+END_EXAMPLE

That makes sense! Looks "horizontal".

* Matrix concatenation
What if I don't feed it strictly 2D matrices?

#+BEGIN_EXAMPLE
>>> arr132 = np.arange(3*2).reshape(1,3,2)
>>> print(arr132)
[[[0 1]
  [2 3]
  [4 5]]]

>>> print(arr132.shape)
(1, 3, 2)
#+END_EXAMPLE

* Matrix concatenation
Same question as before: what do we expect =hstack((arr132,arr132))= to do?

#+BEGIN_EXAMPLE
[[[0 1 0 1]
  [2 3 2 3]
  [4 5 4 5]]]
#+END_EXAMPLE

or

#+BEGIN_EXAMPLE
[[[0 1]
  [2 3]
  [4 5]
  [0 1]
  [2 3]
  [4 5]]]
#+END_EXAMPLE

or something else?

* Matrix concatenation
Here's what it does:

#+BEGIN_EXAMPLE
>>> print(np.hstack((arr132,arr132)))
[[[0 1]
  [2 3]
  [4 5]
  [0 1]
  [2 3]
  [4 5]]]

>>> np.hstack((arr132,arr132)).shape
(1, 6, 2)
#+END_EXAMPLE

Whoa. That is /not/ horizontal at all! I would have expected a result with shape
=(1,3,4)=

* Matrix concatenation
What if I give it 1-dimensional arrays?

#+BEGIN_EXAMPLE
>>> arr3  = np.arange(3)
>>> arr13 = np.arange(3).reshape(1,3)
>>> print(arr3)
[0 1 2]

>>> arr3.shape
(3,)

>>> print(arr13)
[[0 1 2]]

>>> arr13.shape
(1, 3)
#+END_EXAMPLE

* Matrix concatenation
#+BEGIN_EXAMPLE
>>> np.hstack((arr3,arr3)).shape
(6,)

>>> np.hstack((arr13,arr13)).shape
(1, 6)

>>> np.hstack((arr13,arr3)).shape
ValueError: all the input arrays must have ...
    ... same number of dimensions
#+END_EXAMPLE

- Do the stacking functions want the dimension counts to match up, or something?

Well, no:

#+BEGIN_EXAMPLE
>>> np.vstack((arr13,arr3))
[[0 1 2]
 [0 1 2]]
#+END_EXAMPLE

* Matrix concatenation
So what's wrong?

- *numpy is inconsistent about which is the most significant dimension in an
  array*

There's an arbitrary design choice that must be made: if I stack =N= arrays of
shape =(A,B,C)= into a new array, do I get

1. an array of shape =(N,A,B,C)= or
2. an array of shape =(A,B,C,N)=?

Most of numpy makes the /first/ choice, but some of it (concatenation functions
most notably) makes the second choice

* Dimensionality example
Example:

- Let's say I have a 1-dimensional array containing simultaneous temperature
  measurements at different locations:

#+BEGIN_EXAMPLE
>>> print(T1)
[ t_where0 t_where1 t_where2 ... ]

>>> print(T1.shape)
(Nlocations,)

#+END_EXAMPLE

We have one dimension, so the locations are indexed by =axis = 0= and =axis =
-1=. These are the same axis.

* Dimensionality example
Now, let's say I measured all the temperatures multiple times throughout the
day, and I record the measurements into a joint array =T2=.

I have a choice:

#+begin_example
>>> print(T2.shape)
(Ntimes,Nlocations)
#+end_example

or

#+begin_example
>>> print(T2.shape)
(Nlocations,Ntimes)
#+end_example

?

* Dimensionality example
When I extend =T1= into =T2= I want consistent printing:

/The dimensions printed horizontally and vertically should not change/

I.e. I want this:

#+BEGIN_EXAMPLE
>>> print(T2)
[[ t_when0where0 t_when0where1 t_when0where2 ... ]
 [ t_when1where0 t_when1where1 t_when1where2 ... ]
 ...]

>>> print(T2.shape)
(Ntimes, Nlocations)
#+END_EXAMPLE

This way each horizontal row describes /one/ point in time and /multiple/
locations, just like when printing =T1=

* Dimensionality example
When I extend =T1= into =T2= I want consistent indexing:

/The axis index corresponding to locations should not change/

- For =T1=, locations are in =axis = 0= and =axis = -1= (same axis)
- For =T2=, locations are in =axis = 1= and =axis = -1= (same axis)

So counting /from the back/ gives me consistency, and I want to always use =axis
= -1=

Thus I want

- The /first/ concatenation option: stacking =N= arrays of shape =(A,B,C)=
  produces an array of shape =(N,A,B,C)=
- All axes to be indexed from the end. Always.

* Dimensionality example
If we really wanted to index the axes from the front while remaining
self-consistent, numpy could do what PDL does:

- the horizontally-printed dimension is the /first/ dimension
- =N= arrays of shape =(A,B,C)= produce an array of shape =(A,B,C,N)=

But then a core convention of linear algebra would be violated: a matrix of =N=
rows and =M= columns would have shape =(M,N)=. Can't please everybody.

* Matrix concatenation: conclusion
So why are =hstack()= and friends weird?

- Because =hstack()= tries to concatenate along =axis = 1=, while it should use
  =axis = -1=
- This works for 2D arrays (and 1D arrays because of special-case logic in
  =hstack()=), but not for others

Many other core functions in numpy have this issue, and routines in =numpysane=
do this in a consistent and predictable way.

** notes                                                           :noexport:
I can keep pointing out issues in these functions for a long time, but that's
not useful: they're all broken.

Fundamental issue: an inconsistent dimensionality convention.

The way arrays are printed, the innermost dimension is the /last/ one: the
dimension printed horizontal is =axis = -1=. So axes should be counted from the
end. But the numpy functions for concatenation count them from the front.

* Matrix concatenation with numpysane
There are two functions, both stolen from the PDL project.

- =glue()= concatenates any N arrays along the given axis
- =cat()= concatenates N arrays along a new outer dimension

These both add leading length-1 dimensions to the input as needed: "something"
is logically equivalent to "1 of something". This is one of the /broadcasting/
rules I'll get to in a bit

** notes                                                           :noexport:
Nothing is "horizontal" or "vertical". axes should be given from the end
(axis<0). Some functions actually require this: glue(axis>=0) will barf

* Matrix concatenation with numpysane
=nps.glue()= works as expected:

#+BEGIN_EXAMPLE
>>> import numpysane as nps

>>> nps.glue(arr32, arr32,  axis=-1).shape
(3, 4)

>>> nps.glue(arr32, arr32,  axis=-2).shape
(6, 2)

>>> nps.glue(arr132,arr132, axis=-1).shape
(1, 3, 4)

>>> nps.glue(arr13, arr3,   axis=-1).shape
(1, 6)

>>> nps.glue(arr13, arr3,   axis=-2).shape
(2, 3)
#+END_EXAMPLE

* Matrix concatenation with numpysane
=nps.cat()= works as expected too. It always adds a new leading dimension

#+BEGIN_EXAMPLE
>>> nps.cat(arr32,arr32).shape
(2, 3, 2)

>>> nps.cat(arr132,arr32).shape
(2, 1, 3, 2)
#+END_EXAMPLE

* Matrix multiplication
The funny business extends to other core areas of numpy. For instance
multiplying matrices is non-trivial

- Up until numpy 1.10.0 =np.dot()= was the function for that, and it is
  surprising in all sorts of ways (which should be expected since a "dot
  product" is not the same thing as "matrix multiplication")
- In 1.10.0 we got =np.matmul=, which is /much/ better, but even then it has
  strange corners. Trying to compute an outer product:

#+BEGIN_EXAMPLE
>>> a = np.arange(5).reshape(5,1)
>>> b = np.arange(3)

>>> np.matmul(a,b)
ValueError: matmul: Input operand 1 has a mismatch in
   its core dimension 0, with gufunc signature
   (n?,k),(k,m?)->(n?,m?) (size 3 is different from 1)
#+END_EXAMPLE

* Matrix multiplication with numpysane
numpysane provides its own =matmult()= routine that does what one expects:

#+BEGIN_EXAMPLE
>>> nps.matmult(a,b).shape

(5, 3)
#+END_EXAMPLE

There're many more functions in numpysane in this area. Everything's documented,
and I'd like to move on to...

* Broadcasting
What is broadcasting?

- /Broadcasting/ is a generic way to vectorize functions
- A broadcasting-aware function has a /prototype/: it knows the dimensionality
  of its inputs and of its outputs
- When calling a broadcasting-aware function, any extra dimensions in the input
  are automatically used for vectorization

* Broadcasting: an example
This is best described with an example: a broadcasting-aware inner product. An
inner product (also known as a dot product) is a function that

- takes in two identically-sized 1-dimensional arrays
- outputs a scalar

=inner( [ 1 2 3 4], [1 2 3 4] )= \rightarrow =30=

* Broadcasting: an example
If one calls a broadcasting-aware inner product (such as =nps.inner()=) with two
arrays of shape (2,3,4) as input, it would

- compute 6 inner products of length-4 each
- report the output in an array of shape (2,3)

Because =nps.inner()= knows the dimensionality of its inputs and of its outputs,
it can figure out how to parse the input arrays

* Broadcasting: an example
#+BEGIN_EXAMPLE
>>> a234 = np.arange(2*3*4).reshape(2,3,4)

>>> print(a234)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]

>>> print(nps.inner(a234,a234))
[[  14  126  366]
 [ 734 1230 1854]]
#+END_EXAMPLE

The values in the output are =inner([0,1,2,3], [0,1,2,3])= and
=inner([4,5,6,7],[4,5,6,7])= and so on.

* Broadcasting rules
In short:

- Line up the shapes of the inputs to their /trailing/ dimensions
- Match the trailing dimensions with the expected shapes of the inputs
- Any leading dimensions left over are used for vectorization
- The extra leading dimensions must be compatible across all the inputs. This
  means that each leading dimension must either
  - equal 1
  - be missing (thus assumed to equal 1)
  - equal to some positive integer >1, consistent across all arguments
- The leading dimensions of the inputs determine the shape of the output

* Broadcasting: more involved example
Let's say we have a function with

- input prototype =( (3,), ('n',3), ('n',), ('m',) )=
- output prototype =('n','m')=

Given inputs of shape

#+BEGIN_EXAMPLE
  (1,5,    3)
  (2,1,  8,3)
  (        8)
  (  5,    9)
#+END_EXAMPLE

the broadcasting logic will set =n = 8= and =m = 9=.

The call will then return an output array of shape =(2,5,8,9)=

* OK, so what about broadcasting?
In stock numpy, broadcasting is documented, but
- it is sparse and incomplete
- little end-user awareness that it exists

=numpysane= provides routines to add broadcasting awareness

- to any python function (via a decorator)
- to any C function (via generated C code that produces an extension module)

* Broadcasting: an example
Let's write a broadcasting-aware inner product.

#+BEGIN_EXAMPLE
import numpysane as nps
@nps.broadcast_define( (('n',), ('n',)), () )
def inner(a,b):
    # We could use numpy for this: return a.dot(b)
    sum = 0.
    for i in range(len(a)): sum += a[i]*b[i]
    return sum
#+END_EXAMPLE

* Broadcasting: an example
- We had a function =inner(a,b)= that computes /one/ inner product. It knows
  nothing about vectorization
- And it assumes that =a= and =b= are 1-dimensional arrays of the same length
- Then we applised the =nps.broadcast_define()= decorator to add broadcasting
  awareness
- The decorator is told about the number of input and outputs and all of their
  expected dimensions
- The internal =nps.broadcast_define()= machinery ensures that the dimensions of
  the given inputs and outputs match. If not, it raises an exception
- If we call =inner()= with higher-dimensional input, we'll get multiple inner
  products computed, and an array of output returned

* Broadcasting: an example
So we can give it two arrays, and get inner products of each corresponding row:

#+BEGIN_EXAMPLE
>>> a234 = np.arange(2*3*4).reshape(2,3,4)

>>> print(inner(a234,a234).shape)
(2,3)
#+END_EXAMPLE

Or we can compute the inner product of some arbitrary vector and each row of one array:

#+BEGIN_EXAMPLE
>>> a234 = np.arange(2*3*4).reshape(2,3,4)
>>> a4   = np.arange(4)

>>> print(inner(a234,a4).shape)
(2,3)
#+END_EXAMPLE

* Broadcasting: summary
- This is a very powerful technique. The =nps.broadcast_define()= decorator is
  written in Python and wraps Python code. With lots of iterations this is
  /slow/.

- A much faster analogue exists in C: =nps.numpysane_pywrap()=. The iteration
  code and the code for the inner function are all in C, so this is fast. Please
  see the documentation for more detail.

- A stock numpy broadcasting-in-C API exists:

  https://docs.scipy.org/doc/numpy-1.13.0/reference/c-api.generalized-ufuncs.html

  I found this after implementing my own, and have not tried it.

* Plotting: gnuplotlib
Let's switch gears, and talk about plotting.

- As with the numpy core, there's a dominant choice here: matplotlib
- I'm not aware of any /major/ issues: if it's not pissing you off right now,
  there probably isn't a lot of reason to switch to my library

However, matplotlib ...

- is python-specific
- is slow
- has a weird API
- is missing useful interactivity

** notes                                                           :noexport:
At this point in my perl -> python transition I was getting peeved. I didn't see
anything as egregiously annoying in matplotlib as in core numpy, but it does a
whole lotta stuff that I don't like, so I decided to fix that too.

* Plotting: gnuplotlib
=gnuplotlib=: a plotting library for numpy

- Uses =gnuplot= as the plotting backend, so
  - The plots look and interact like =gnuplot= plots have for decades
  - It's fast
  - Lots of features and backends available

- Has a (claimed) reasonable API
- A direct port of =PDL::Graphics::Gnuplot=

** notes                                                           :noexport:

I make a lot of plots in my day to day, outside of python most of the time. I'd
like all my plots to look and feel the same. There's absolutely no reason for
any numpy-based plotting library to actually implement their own backend. If
their backend is amazing, then everybody else (python or not) should use it. If
it's not amazing, they should find an amazing one, and use it.

I'm sure matplotlib is more powerful than gnuplot in some ways, but when they
rewrote that particular world, they missed lots of nice things.

* Plotting: gnuplotlib design choices
- One =plot()= function does everything
  - Can still build up the plot components programmatically with python
- =gnuplotlib= is a thin shim: strings are passed to =gnuplot= verbatim (like in
  =feedgnuplot=)
  - So we get a powerful library and a friendly learning curve

Introductory tutorial is available at

https://github.com/dkogan/gnuplotlib/blob/master/guide/guide.org

** notes                                                           :noexport:
Similar design choices as with feedgnuplot: the sysmtem is as hands-off as
possible. Any styling directives are passed on to gnuplot directly.

There's one class gnuplotlib: one instance is one gnuplot process and one plot
window. There's one plotting function.

The various datasets and directives are all given to this one function with one
function call. If we need to gather many arguments to make a complicated plot,
we can build them up using the language we already have: python. This is in
contrast to how matplotlib does it, where you make multiple function calls to do
anything, and thus there's an API to learn.

* Plotting: gnuplotlib: a /very/ brief tutorial
To plot something, just call plot:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot(np.sin(th))
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
import numpy      as np
import numpysane  as nps
import gnuplotlib as gp
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot(np.sin(th))
#+END_SRC

- We're plotting in 2D, so default is =tuplesize=2= arrays
- We gave it just 1 array, so integers 0,1,2,... were used for the x

* Plotting: gnuplotlib: a /very/ brief tutorial
- We can pass in 2 arrays to make a scatter x-y plot:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th), square = True)
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th), square = True)
#+END_SRC

- We passed in /two/ arrays
- We also passed in =square = True=. This is a /plot option/ to autoscale the x
  and y axes evenly. Otherwise the circle will looks like an ellipse

* Plotting: gnuplotlib: a /very/ brief tutorial
- It's possible to have more values per point. For instance:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th),
        # The angle (in degrees) is shown as the color
        th * 180./np.pi,
        tuplesize = 3,
        _with     = 'linespoints palette',
        square    = True)
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-np.pi, np.pi, 100)
gp.plot(np.cos(th), np.sin(th),
        # The angle (in degrees) is shown as the color
        th * 180./np.pi,
        tuplesize = 3,
        _with     = 'linespoints palette',
        square    = True)
#+END_SRC

- The style =linespoints palette= is given to =gnuplot= directly. =gnuplotlib=
  doesn't know what that means
- =tuplesize=3= tells =gnuplotlib= that there are 3 values per point. Because of
  =palette=, these will be interpreted as x,y,color
- The =gnuplot= documentation talks in detail about what kind of input each
  style expects

* Plotting: gnuplotlib: a /very/ brief tutorial
An explicit invocation of =plot()= looks like this:

#+BEGIN_SRC python :exports code
plot( curve, curve, ..., plot_options )
#+END_SRC

where each =curve= is a =tuple=:

#+BEGIN_SRC python :exports code
curve = (array, array, ..., curve_options)
#+END_SRC

- /plot options/ apply to the whole plot, and are given as keyword args to
  =plot()=
- /curve options/ apply to each separate curve (dataset); given in a =dict()= in
  the end of each =curve= tuple. Or defaults given in the =plot()= kwargs
- If we have one dataset, we can inline the tuples, like we did above

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( ( th, np.sin(th), ),
         ( th, np.cos(th), ),
         ( th, th, dict(_with = 'points ps 1') ),
         _with = 'lines',
         xlabel = "Angle (rad)",
         title  = "2 with lines and 1 with points")
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( ( th, np.sin(th), ),
         ( th, np.cos(th), ),
         ( th, th, dict(_with = 'points ps 1') ),
         _with = 'lines',
         xlabel = "Angle (rad)",
         title  = "2 with lines and 1 with points")
#+END_SRC

- We passed in 3 tuples, one for each dataset
- We passed in the =xlabel= plot option to label the x axis
- We passed in the =title= plot option to title the plot
- We passed in the default =with= curve option: =lines=
- 2/3 datasets don't set their own =with=, so they use =lines=
- 1/3 plots with =points ps 1= instead. =gnuplotlib= doesn't know what that is,
  but =gnuplot= knows that =ps= is a synonym for =pointsize=

** notes                                                           :noexport:
The arguments can be built up incrementally with python

* Plotting: gnuplotlib: a /very/ brief tutorial
- Broadcasting is fully supported:

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports both
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( th,
         nps.cat(np.sin(th),
                 np.cos(th)),
         legend = np.array( ("sin", "cos"), ) )
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial
#+BEGIN_SRC python :results none :exports code
th = np.linspace(-2.*np.pi, 2.*np.pi, 100)
gp.plot( th,
         nps.cat(np.sin(th),
                 np.cos(th)),
         legend = np.array( ("sin", "cos"), ) )
#+END_SRC

- I plotted two datasets, but didn't use tuples
- Using default =tuplesize=2=, and gave it two arrays:
  - First array has the expected shape of =(100,)=
  - Second array has the shape =(2,100)=
- This thus broadcasts: I get two plots: =sin(th)= vs =th= and =cos(th)= vs
  =th=
- curve options broadcast too: I have it two different =legend= options, and
  =gnuplotlib= knows to use each one for the two datasets

* Plotting: gnuplotlib: a /very/ brief tutorial

- What does this do?

#+BEGIN_SRC python :results none exports code
th    = np.linspace(0, 6*np.pi, 200)
z     = np.linspace(0, 5,       200)
size  = 0.5 + np.abs(np.cos(th))
color = np.sin(2*th)

gp.plot3d( np.cos(th) * nps.transpose(np.array((1,-1))),
           np.sin(th) * nps.transpose(np.array((1,-1))),
           z,
           size,
           color,
           tuplesize = 5,
           _with = 'points ps variable pt 7 palette',
           squarexy = True)
#+END_SRC

* Plotting: gnuplotlib: a /very/ brief tutorial

#+BEGIN_SRC python :python python3 :results file link :session gnuplotlib-talk :exports results :height 9
th    = np.linspace(0, 6*np.pi, 200)
z     = np.linspace(0, 5,       200)
size  = 0.5 + np.abs(np.cos(th))
color = np.sin(2*th)

gp.plot3d( np.cos(th) * nps.transpose(np.array((1,-1))),
           np.sin(th) * nps.transpose(np.array((1,-1))),
           z,
           size,
           color,
           tuplesize = 5,
           _with = 'points ps variable pt 7 palette',
           squarexy = True)
#+END_SRC

* Plotting: gnuplotlib

More or less that's it. Lots of examples in the guide:
- https://github.com/dkogan/gnuplotlib/blob/master/guide/guide.org

The API docs are on the main page:
- https://github.com/dkogan/gnuplotlib

* Thanks for listening!
The documentation and sources and links to this talk:

- https://github.com/dkogan/numpysane
- https://github.com/dkogan/gnuplotlib

Or you can

#+begin_example
apt install python3-numpysane python3-gnuplotlib
#+end_example

* init                                                             :noexport:
Local Variables:
eval: (progn
          (require 'ox-beamer)
          (setq org-confirm-babel-evaluate nil)
          (org-babel-do-load-languages
           'org-babel-load-languages
            '((python  . t)))
          (auto-fill-mode)
;; This is all very convoluted. There are 3 different advices, commented in
;; place
;;
;; THIS advice makes all the org-babel parameters available to python in the
;; _org_babel_params dict. I care about _org_babel_params['_file'] specifically,
;; but everything is available
(defun dima-org-babel-python-var-to-python (var)
  "Convert an elisp value to a python variable.
  Like the original, but supports (a . b) cells and symbols
"
  (if (listp var)
      (if (listp (cdr var))
          (concat "[" (mapconcat #'org-babel-python-var-to-python var ", ") "]")
        (format "\"\"\"%s\"\"\"" var))
    (if (symbolp var)
        (format "\"\"\"%s\"\"\"" var)
      (if (eq var 'hline)
          org-babel-python-hline-to
        (format
         (if (and (stringp var) (string-match "[\n\r]" var)) "\"\"%S\"\"" "%S")
         (if (stringp var) (substring-no-properties var) var))))))
(defun dima-alist-to-python-dict (alist)
  "Generates a string defining a python dict from the given alist"
  (let ((keyvalue-list
         (mapcar (lambda (x)
                   (format "%s = %s, "
                           (replace-regexp-in-string
                            "[^a-zA-Z0-9_]" "_"
                            (symbol-name (car x)))
                           (dima-org-babel-python-var-to-python (cdr x))))
                 alist)))
    (concat
     "dict( "
     (apply 'concat keyvalue-list)
     ")")))
(defun dima-org-babel-python-pass-all-params (f params)
  (cons
   (concat
    "_org_babel_params = "
    (dima-alist-to-python-dict params))
   (funcall f params)))
(unless
    (advice-member-p
     #'dima-org-babel-python-pass-all-params
     #'org-babel-variable-assignments:python)
  (advice-add
   #'org-babel-variable-assignments:python
   :around #'dima-org-babel-python-pass-all-params))
;; This sets a default :file tag, set to a unique filename. I want each demo to
;; produce an image, but I don't care what it is called. I omit the :file tag
;; completely, and this advice takes care of it
(defun dima-org-babel-python-unique-plot-filename
    (f &optional arg info params)
  (funcall f arg info
           (cons (cons ':file
                       (format "plot-%d.pdf"
                               (condition-case nil
                                   (setq dima-unique-plot-number (1+ dima-unique-plot-number))
                                 (error (setq dima-unique-plot-number 0)))))
                 params)))
(unless
    (advice-member-p
     #'dima-org-babel-python-unique-plot-filename
     #'org-babel-execute-src-block)
  (advice-add
   #'org-babel-execute-src-block
   :around #'dima-org-babel-python-unique-plot-filename))
;; If I'm regenerating ALL the plots, I start counting the plots from 0
(defun dima-reset-unique-plot-number
    (&rest args)
    (setq dima-unique-plot-number 0))
(unless
    (advice-member-p
     #'dima-reset-unique-plot-number
     #'org-babel-execute-buffer)
  (advice-add
   #'org-babel-execute-buffer
   :after #'dima-reset-unique-plot-number))
;; I'm using github to display guide.org, so I'm not using the "normal" org
;; exporter. I want the demo text to not contain the hardcopy= tags, but clearly
;; I need the hardcopy tag when generating the plots. I add some python to
;; override gnuplotlib.plot() to add the hardcopy tag somewhere where the reader
;; won't see it. But where to put this python override code? If I put it into an
;; org-babel block, it will be rendered, and the :export tags will be ignored,
;; since github doesn't respect those (probably). So I put the extra stuff into
;; an advice. Whew.
(defun dima-org-babel-python-set-demo-output (f body params)
  (with-temp-buffer
    (insert body)
    (beginning-of-buffer)
    (when (search-forward "import gnuplotlib as gp" nil t)
      (end-of-line)
      (insert
       "\n"
       "if not hasattr(gp.gnuplotlib, 'orig_init'):\n"
       "    gp.gnuplotlib.orig_init = gp.gnuplotlib.__init__\n"
       "plot_output_pdf = lambda: dict(hardcopy = _org_babel_params['_file'],\n"
       "                               terminal = 'pdfcairo solid color font \",20\" size 11in,{}in'.format(_org_babel_params.get('_height',5)) if 'file' in _org_babel_params['_result_params'] else {})\n"
       "gp.gnuplotlib.__init__ = lambda self, *args, **kwargs: gp.gnuplotlib.orig_init(self, *args,\n"
       "                                                                               **plot_output_pdf(), **kwargs )\n"))
    (setq body (buffer-substring-no-properties (point-min) (point-max))))
  (funcall f body params))
(unless
    (advice-member-p
     #'dima-org-babel-python-set-demo-output
     #'org-babel-execute:python)
  (advice-add
   #'org-babel-execute:python
   :around #'dima-org-babel-python-set-demo-output))
)
End:
